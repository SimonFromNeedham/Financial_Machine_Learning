"""Picks prospective stocks based on their yield history, instead of using machine learning"""
import pandas as pd
import requests
import yfinance as yf

from simplejson import JSONDecodeError

# PAYOUTS = The number of consecutive quarters the company has paid a dividend
# MARGIN = The max allowed increase of the dividend over that time, which prevents
#          counting massive spikes from isolated events. Set to .36 for inflation * 5
PAYOUTS = 12
MARGIN = .36


def get_ticker_symbols():
    # Returns the ticker symbols of all stocks trading on NASDAQ
    # Code copied from https://github.com/shilewenuw/get_all_tickers/issues/12
    headers = {
        'authority': 'api.nasdaq.com',
        'accept': 'application/json, text/plain, */*',
        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36',
        'origin': 'https://www.nasdaq.com',
        'sec-fetch-site': 'same-site',
        'sec-fetch-mode': 'cors',
        'sec-fetch-dest': 'empty',
        'referer': 'https://www.nasdaq.com/',
        'accept-language': 'en-US,en;q=0.9',
    }

    params = (
        ('tableonly', 'true'),
        ('limit', '25'),
        ('offset', '0'),
        ('download', 'true'),
    )

    r = requests.get('https://api.nasdaq.com/api/screener/stocks', headers=headers, params=params)
    data = r.json()['data']
    df = pd.DataFrame(data['rows'], columns=data['headers'])

    # Cast the DataFrame to a list to enable iteration
    return df['symbol'].to_list()


def consistent_dividends(dividends, margin):
    # Dividends: A series of a stock's latest dividends
    # Margin: The largest acceptable decimal variation of dividends

    # The latest paid dividend
    cur_div = dividends.iloc[-1]

    for i in range(-1, -1 - PAYOUTS, -1):
        # Check that dividends are steadily increasing
        if dividends.iloc[i] < dividends.iloc[i-1]:
            return False

    # Return True for steady dividends, False for recent spikes
    return (cur_div - dividends.iloc[-PAYOUTS]) / cur_div < margin


if __name__ == '__main__':
    # Key = ticker, value = yield
    stocks = dict()

    # Check each stock for viability
    for ticker in get_ticker_symbols():
        # Catch random loading errors that are raised when inaccessible online data is requested
        # These occur frequently when large quantities of data (e.g. dividends, prices) are fetched
        # Index errors are raised when when there's dividend history but no price history, as the
        # algorithm attempts to access last hour's closing price but there's no listings available
        try:
            stock = yf.Ticker(ticker)
            dividends = stock.dividends

            # Only consider stocks which have a dividend payout history
            if len(dividends) > PAYOUTS and consistent_dividends(dividends, MARGIN):
                price = stock.history(period="1h")['Close'][0]

                # Calculate the current yield --> round it and use it as a key
                # Use "yields" instead of "yield" because the latter is a key word
                # Multiply by 400 for quarterly dividends, measured as a percentile
                yields = round(400 * dividends.iloc[-1] / price, 3)

                # Cut out unrealistic stocks generated by sparse, inaccurate data
                if yields < 100:
                    stocks[ticker] = yields

        except (JSONDecodeError, IndexError) as e:
            print(e)

    # Sort the stocks dictionary by yield, then print the algorithm's top 100 resulting picks
    # Reverse so that the stocks are sorted in descending order (i.e. highest to lowest yields)
    # Code copied from https://stackoverflow.com/questions/613183/how-do-i-sort-a-dictionary-by-value
    # "float(item[1])": https://stackoverflow.com/questions/14591435/sorted-only-sorting-by-first-digit
    stocks = sorted(stocks.items(), key=lambda item: float(item[1]), reverse=True)

    for stock in stocks[:100]:
        # Concatenate a more comprehensible result
        print(stock[0] + ': ' + str(stock[1]) + '%')
